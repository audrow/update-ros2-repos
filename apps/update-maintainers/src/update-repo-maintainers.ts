import endent from 'endent'
import fs from 'fs'
import glob from 'glob'
import {join} from 'path'
import {fileSystem} from 'ros2-cache'
import * as z from 'zod'
import {MaintainersInfo} from '../src/maintainers-info-helpers'
import * as packageXml from '../src/package-xml'
import type {SetMaintainersOptions as SetSetupPyMaintainerOptions} from '../src/setup-py'
import * as setupPy from '../src/setup-py'
import type {Person} from '../src/__types__'

export const updateRepoOptionsSchema = z
  .object({
    repoPath: z.string(),
    repoName: z.string(),
    newBranchName: z.string(),
    baseBranchName: z.string(),
    generatedByRepoUrl: z.string().url().optional(),
  })
  .merge(setupPy.setMaintainersOptionsSchema)
  .merge(MaintainersInfo)

export type UpdateRepoOptions = z.infer<typeof updateRepoOptionsSchema>

export async function updateRepoMaintainers(options: UpdateRepoOptions) {
  const {
    repoPath,
    repoName,
    maintainers,
    newBranchName,
    baseBranchName,
    generatedByRepoUrl,
  } = updateRepoOptionsSchema.parse(options)

  await fileSystem.createNewBranch({repoPath, newBranchName, baseBranchName})

  let isAddCodeOwners = true
  try {
    console.log(`Adding CODEOWNERS file to ${repoName}`)
    createCodeOwnersFile({
      repoPath,
      codeOwnersGithubIds: maintainers.map((m) => m.id),
      generatedByRepoUrl,
    })
    await fileSystem.createCommit({
      repoPath,
      commitMessage: `Add ${andList(
        maintainers.map((m) => m.name),
      )} as code owners`,
    })
  } catch (error) {
    console.error(
      `Failed to add CODEOWNERS file to ${repoName}: `,
      JSON.stringify(error, null, 2),
    )
    isAddCodeOwners = false
  }

  let isUpdateMaintainers = true
  try {
    console.log(`Updating Maintainers files to ${repoName}`)
    await updatePackageXmlMaintainers({repoPath, maintainers})
    await updateSetupPyMaintainers({repoPath, maintainers, options})
    await fileSystem.createCommit({
      repoPath,
      commitMessage: `Update maintainers to ${andList(
        maintainers.map((m) => m.name),
      )}`,
    })
  } catch (error) {
    console.error(
      `Failed to update maintainers files in ${repoName}:`,
      JSON.stringify(error, null, 2),
    )
    isUpdateMaintainers = false
  }
  return {
    isAddCodeOwners,
    isUpdateMaintainers,
  }
}

function andList(items: string[]) {
  const lastItem = items.pop()
  return `${items.join(', ')}, and ${lastItem}`
}

function createCodeOwnersFile({
  repoPath,
  codeOwnersGithubIds,
  generatedByRepoUrl,
}: {
  repoPath: string
  codeOwnersGithubIds: string[]
  generatedByRepoUrl?: string
}) {
  const files = glob.sync(join(repoPath, '**', 'CODEOWNERS'))
  const isCodeOwnersFile = files.length > 0
  if (isCodeOwnersFile) {
    throw new Error(`CODEOWNERS file already exists: ${JSON.stringify(files)}`)
  } else {
    const codeOwnersPath = join(repoPath, 'CODEOWNERS')
    const maintainersString = codeOwnersGithubIds.map((m) => `@${m}`).join(' ')
    let codeOwnersContent = `* ${maintainersString}\n`
    if (generatedByRepoUrl) {
      codeOwnersContent = endent`
        # This file was generated by ${generatedByRepoUrl}
        ${codeOwnersContent}
      `
    }
    fs.writeFileSync(codeOwnersPath, codeOwnersContent)
  }
}

async function updateSetupPyMaintainers({
  repoPath,
  maintainers,
  options,
}: {
  repoPath: string
  maintainers: Person[]
  options?: SetSetupPyMaintainerOptions
}) {
  const files = glob.sync(join(repoPath, '**', 'setup.py'))
  for (const file of files) {
    const content = fs.readFileSync(file, 'utf8')
    const newContent = setupPy.setMaintainers(content, maintainers, options)
    fs.writeFileSync(file, newContent)
  }
}

async function updatePackageXmlMaintainers({
  repoPath,
  maintainers,
}: {
  repoPath: string
  maintainers: Person[]
}) {
  const files = glob.sync(join(repoPath, '**', 'package.xml'))
  for (const file of files) {
    const content = fs.readFileSync(file, 'utf8')
    const newContent = packageXml.setMaintainers(content, maintainers)
    fs.writeFileSync(file, newContent)
  }
}

async function main() {
  const cache = (await import('ros2-cache')).cache
  const copy = (await import('recursive-copy')).default

  const outputDir = join(__dirname, '..', 'out')
  const cacheDir = join(__dirname, '..', 'cache')

  const version = 'rolling'
  const repoOrg = 'ros2'
  const repoName = 'rclpy'
  const repoUrl = 'https://github.com/audrow/rclcpp'
  const repoPath = join(outputDir, repoOrg, repoName)
  const maxLineLength = 99

  const newMaintainers = [
    {
      name: 'Audrow Nash',
      email: 'audrow@hey.com',
      id: 'audrow',
    },
    {
      name: 'Chris Lalancette',
      email: 'clalancette@openrobotics.org',
      id: 'clalancette',
    },
    {
      name: 'William Woodall',
      email: 'wjwood@openrobotics.org',
      id: 'wjwwood',
    },
  ]

  // setup files
  cache.makeCacheDir({path: cacheDir, isForceRefresh: false})
  cache.makeCacheDir({path: outputDir, isForceRefresh: true})
  await cache.pullGitRepo({
    url: repoUrl,
    version: version,
    destinationPath: join(cacheDir, repoOrg, repoName),
  })
  await copy(cacheDir, outputDir, {dot: true})

  // await fileSystem.resetBranch({repoPath, version: `origin/${version}`})
  await updateRepoMaintainers({
    repoPath,
    repoName,
    maintainers: newMaintainers,
    maxLineLength,
    baseBranchName: version,
    newBranchName: 'update-maintainers',
  })
}

if (require.main === module) {
  main()
}
