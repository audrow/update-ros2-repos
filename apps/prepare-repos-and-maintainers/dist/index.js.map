{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import {parse as csvParse} from 'csv-parse/sync'\nimport fs from 'fs'\nimport fetch from 'node-fetch'\nimport path from 'path'\nimport * as z from 'zod'\n\nconst repoFromUrlSchema = z.object({\n  org: z.string(),\n  name: z.string(),\n  url: z.string().url(),\n  validUrl: z.boolean().nullable(),\n})\n\ntype RepoFromUrl = z.infer<typeof repoFromUrlSchema>\n\nconst repoSchema = z\n  .object({\n    maintainers: z.array(z.string().min(1)),\n  })\n  .merge(repoFromUrlSchema)\n\ntype Repo = z.infer<typeof repoSchema>\n\nexport async function getRepos({\n  maintainersCsvData,\n  headingRowNumber,\n  maintainersStartColumnLetter,\n  reposColumnLetter,\n  githubUrlPrefix,\n  isCheckUrls,\n}: {\n  maintainersCsvData: string[][]\n  headingRowNumber: number\n  maintainersStartColumnLetter: string\n  reposColumnLetter: string\n  githubUrlPrefix: string\n  isCheckUrls: boolean\n}) {\n  const heading = maintainersCsvData[headingRowNumber - 1]\n  const people = z\n    .array(z.string().min(2))\n    .parse(heading.slice(letterToIndex(maintainersStartColumnLetter)))\n\n  const repos: Repo[] = await Promise.all(\n    maintainersCsvData\n      .splice(headingRowNumber)\n      .filter((row: string[]) => {\n        const repoString = row[letterToIndex(reposColumnLetter)]\n        return repoString.split('/').length === 2\n      })\n      .map(async (row: string[]) => {\n        const repoString = z\n          .string()\n          .parse(row[letterToIndex(reposColumnLetter)])\n        const isMaintainer = z\n          .array(\n            z.preprocess((x: unknown) => {\n              if (x === '') {\n                return false\n              }\n              return Number.parseFloat(x as string) > 0\n            }, z.boolean()),\n          )\n          .length(people.length)\n          .parse(row.slice(letterToIndex(maintainersStartColumnLetter)))\n        const maintainers = people.filter(\n          (_: string, index: number) => isMaintainer[index],\n        )\n        const repoFromUrl = await getRepoFromString(\n          repoString,\n          githubUrlPrefix,\n          isCheckUrls,\n        )\n        return repoSchema.parse({\n          ...repoFromUrl,\n          maintainers,\n        })\n      }),\n  )\n\n  return repos\n}\n\nasync function getRepoFromString(\n  repoString: string,\n  githubUrlPrefix: string,\n  checkUrl = false,\n): Promise<RepoFromUrl> {\n  const [org, name] = repoString.split('/')\n  const url = `${githubUrlPrefix}${org}/${name}`\n\n  let validUrl: boolean | null = null\n  if (checkUrl) {\n    const {status} = await fetch(url)\n    validUrl = status === 200\n    if (validUrl === false) {\n      console.log(`repo ${url} returned status ${status}`)\n    }\n  }\n\n  return {\n    org,\n    name,\n    url,\n    validUrl,\n  }\n}\n\nfunction letterToIndex(letter: string): number {\n  return z.string().length(1).parse(letter).charCodeAt(0) - 97\n}\n\nasync function main() {\n  const maintainersCsv = fs.readFileSync(\n    path.join(__dirname, '..', 'data', '2022-09-14-maintainers.csv'),\n  )\n  const data = csvParse(maintainersCsv)\n\n  const reposColumnLetter = 'a'\n  const maintainersStartColumnLetter = 'n'\n  const headingRowNumber = 2\n  const isCheckUrls = true\n\n  const githubUrlPrefix = 'https://github.com/'\n\n  const repos = await getRepos({\n    maintainersCsvData: data,\n    headingRowNumber,\n    maintainersStartColumnLetter,\n    reposColumnLetter,\n    githubUrlPrefix,\n    isCheckUrls,\n  })\n\n  repos.forEach((r) => {\n    console.log(r)\n  })\n}\n\nmain()\n"],"mappings":"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","names":["fetch","fs","path","csvParse"]}